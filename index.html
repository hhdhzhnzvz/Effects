<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Эффектный симулятор рисования</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #ui {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 2;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            color: white;
            max-width: 300px;
        }
        #effect-selector {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        .effect-btn {
            padding: 5px;
            border: 1px solid #444;
            border-radius: 5px;
            background: #222;
            color: white;
            cursor: pointer;
            text-align: center;
            font-size: 12px;
        }
        .effect-btn.active {
            background: #4a6;
            border-color: #6c8;
        }
        #instructions {
            font-size: 14px;
            margin-bottom: 10px;
        }
        #color-picker {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        .color-option {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
        }
        .color-option.active {
            border-color: white;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="ui">
        <div id="instructions">Водите мышкой/пальцем по экрану для создания эффектов</div>
        <div id="color-picker">
            <div class="color-option active" style="background: #ff0000;" data-color="#ff0000"></div>
            <div class="color-option" style="background: #00ff00;" data-color="#00ff00"></div>
            <div class="color-option" style="background: #0000ff;" data-color="#0000ff"></div>
            <div class="color-option" style="background: #ffff00;" data-color="#ffff00"></div>
            <div class="color-option" style="background: #ff00ff;" data-color="#ff00ff"></div>
            <div class="color-option" style="background: #00ffff;" data-color="#00ffff"></div>
            <div class="color-option" style="background: #ffffff;" data-color="#ffffff"></div>
        </div>
        <div id="effect-selector">
            <div class="effect-btn active" data-effect="1">Огненные частицы</div>
            <div class="effect-btn" data-effect="2">Водные круги</div>
            <div class="effect-btn" data-effect="3">Звездный след</div>
            <div class="effect-btn" data-effect="4">Радужные линии</div>
            <div class="effect-btn" data-effect="5">Клеточный автомат</div>
            <div class="effect-btn" data-effect="6">Фрактальные ветви</div>
            <div class="effect-btn" data-effect="7">Электрические разряды</div>
            <div class="effect-btn" data-effect="8">Пузыри</div>
            <div class="effect-btn" data-effect="9">Снежинки</div>
            <div class="effect-btn" data-effect="10">Металлические нити</div>
            <div class="effect-btn" data-effect="11">Дым</div>
            <div class="effect-btn" data-effect="12">Круги пульсации</div>
            <div class="effect-btn" data-effect="13">Спирали</div>
            <div class="effect-btn" data-effect="14">Космический туман</div>
            <div class="effect-btn" data-effect="15">Цветущие узоры</div>
            <div class="effect-btn" data-effect="16">Плавающие шары</div>
            <div class="effect-btn" data-effect="17">Кисть Ван Гога</div>
            <div class="effect-btn" data-effect="18">Квадратная мозаика</div>
            <div class="effect-btn" data-effect="19">Нейронные связи</div>
            <div class="effect-btn" data-effect="20">Геометрический хаос</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Установка размеров canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Настройки
        let currentEffect = 1;
        let currentColor = '#ff0000';
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        
        // Инициализация эффектов
        const effects = {
            // Эффект 1: Огненные частицы
            particles: [],
            
            // Эффект 2: Водные круги
            ripples: [],
            
            // Эффект 3: Звездный след
            stars: [],
            
            // Эффект 4: Радужные линии
            rainbowLines: [],
            
            // Эффект 5: Клеточный автомат
            cells: [],
            cellSize: 20,
            
            // Эффект 6: Фрактальные ветви
            branches: [],
            
            // Эффект 7: Электрические разряды
            lightning: [],
            
            // Эффект 8: Пузыри
            bubbles: [],
            
            // Эффект 9: Снежинки
            snowflakes: [],
            
            // Эффект 10: Металлические нити
            metallicThreads: [],
            
            // Эффект 11: Дым
            smokeParticles: [],
            
            // Эффект 12: Круги пульсации
            pulseCircles: [],
            
            // Эффект 13: Спирали
            spirals: [],
            
            // Эффект 14: Космический туман
            spaceDust: [],
            
            // Эффект 15: Цветущие узоры
            flowerParticles: [],
            
            // Эффект 16: Плавающие шары
            floatingBalls: [],
            
            // Эффект 17: Кисть Ван Гога
            vanGoghBrush: [],
            
            // Эффект 18: Квадратная мозаика
            squareTiles: [],
            
            // Эффект 19: Нейронные связи
            neurons: [],
            
            // Эффект 20: Геометрический хаос
            chaosShapes: []
        };
        
        // Обработчики событий
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        
        // Кнопки выбора эффекта
        document.querySelectorAll('.effect-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.effect-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentEffect = parseInt(this.dataset.effect);
                clearCanvas();
            });
        });
        
        // Выбор цвета
        document.querySelectorAll('.color-option').forEach(option => {
            option.addEventListener('click', function() {
                document.querySelectorAll('.color-option').forEach(o => o.classList.remove('active'));
                this.classList.add('active');
                currentColor = this.dataset.color;
            });
        });
        
        function startDrawing(e) {
            isDrawing = true;
            [lastX, lastY] = getCoordinates(e);
            createEffect(lastX, lastY);
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            startDrawing(touch);
        }
        
        function draw(e) {
            if (!isDrawing) return;
            const [x, y] = getCoordinates(e);
            createEffect(x, y);
            
            // Для некоторых эффектов важно знать направление движения
            const dx = x - lastX;
            const dy = y - lastY;
            
            // Обновляем позицию
            lastX = x;
            lastY = y;
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            draw(touch);
        }
        
        function stopDrawing() {
            isDrawing = false;
        }
        
        function getCoordinates(e) {
            let x, y;
            if (e.touches) {
                x = e.touches[0].clientX;
                y = e.touches[0].clientY;
            } else {
                x = e.clientX;
                y = e.clientY;
            }
            return [x, y];
        }
        
        function clearCanvas() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Очищаем массивы частиц для всех эффектов
            for (let key in effects) {
                if (Array.isArray(effects[key])) {
                    effects[key] = [];
                }
            }
        }
        
        function createEffect(x, y) {
            switch(currentEffect) {
                case 1: createFireParticles(x, y); break;
                case 2: createRipple(x, y); break;
                case 3: createStarTrail(x, y); break;
                case 4: createRainbowLine(x, y); break;
                case 5: activateCell(x, y); break;
                case 6: createBranch(x, y); break;
                case 7: createLightning(x, y); break;
                case 8: createBubble(x, y); break;
                case 9: createSnowflake(x, y); break;
                case 10: createMetallicThread(x, y); break;
                case 11: createSmoke(x, y); break;
                case 12: createPulseCircle(x, y); break;
                case 13: createSpiral(x, y); break;
                case 14: createSpaceDust(x, y); break;
                case 15: createFlowerParticle(x, y); break;
                case 16: createFloatingBall(x, y); break;
                case 17: createVanGoghStroke(x, y); break;
                case 18: createSquareTile(x, y); break;
                case 19: createNeuron(x, y); break;
                case 20: createChaosShape(x, y); break;
            }
        }
        
        // Реализации эффектов
        function createFireParticles(x, y) {
            for (let i = 0; i < 5; i++) {
                effects.particles.push({
                    x, y,
                    vx: Math.random() * 4 - 2,
                    vy: Math.random() * -3 - 1,
                    size: Math.random() * 10 + 5,
                    color: `hsl(${Math.random() * 30 + 10}, 100%, 50%)`,
                    life: 100
                });
            }
        }
        
        function createRipple(x, y) {
            effects.ripples.push({
                x, y,
                radius: 5,
                alpha: 1,
                color: currentColor
            });
        }
        
        function createStarTrail(x, y) {
            effects.stars.push({
                x, y,
                size: Math.random() * 3 + 1,
                twinkle: Math.random() * 0.5 + 0.5,
                speed: Math.random() * 0.2 + 0.1
            });
        }
        
        function createRainbowLine(x, y) {
            if (effects.rainbowLines.length === 0) {
                effects.rainbowLines.push({ points: [{x, y, hue: 0}] });
            } else {
                const lastPoint = effects.rainbowLines[0].points[effects.rainbowLines[0].points.length - 1];
                const hue = (lastPoint.hue + 2) % 360;
                effects.rainbowLines[0].points.push({x, y, hue});
                if (effects.rainbowLines[0].points.length > 50) {
                    effects.rainbowLines[0].points.shift();
                }
            }
        }
        
        function activateCell(x, y) {
            const col = Math.floor(x / effects.cellSize);
            const row = Math.floor(y / effects.cellSize);
            const index = row * Math.ceil(canvas.width / effects.cellSize) + col;
            
            if (!effects.cells[index]) {
                effects.cells[index] = {
                    active: true,
                    energy: 1,
                    neighbors: []
                };
            } else {
                effects.cells[index].active = true;
                effects.cells[index].energy = 1;
            }
        }
        
        function createBranch(x, y) {
            effects.branches.push({
                x, y,
                angle: Math.random() * Math.PI * 2,
                length: 10,
                depth: 0,
                maxDepth: 5
            });
        }
        
        function createLightning(x, y) {
            effects.lightning.push({
                x, y,
                segments: [],
                life: 30
            });
        }
        
        function createBubble(x, y) {
            effects.bubbles.push({
                x, y,
                radius: Math.random() * 20 + 10,
                vx: Math.random() * 2 - 1,
                vy: Math.random() * -1 - 0.5,
                color: `hsla(${Math.random() * 360}, 80%, 60%, 0.7)`
            });
        }
        
        function createSnowflake(x, y) {
            effects.snowflakes.push({
                x, y,
                size: Math.random() * 8 + 4,
                branches: Math.floor(Math.random() * 4) + 4,
                angle: Math.random() * Math.PI * 2,
                rotationSpeed: Math.random() * 0.02 - 0.01
            });
        }
        
        function createMetallicThread(x, y) {
            if (effects.metallicThreads.length === 0) {
                effects.metallicThreads.push({ points: [{x, y}] });
            } else {
                effects.metallicThreads[0].points.push({x, y});
                if (effects.metallicThreads[0].points.length > 100) {
                    effects.metallicThreads[0].points.shift();
                }
            }
        }
        
        function createSmoke(x, y) {
            for (let i = 0; i < 3; i++) {
                effects.smokeParticles.push({
                    x, y,
                    vx: Math.random() * 2 - 1,
                    vy: Math.random() * -1 - 0.5,
                    size: Math.random() * 15 + 5,
                    alpha: 0.8,
                    color: `rgba(150, 150, 150, 0.8)`
                });
            }
        }
        
        function createPulseCircle(x, y) {
            effects.pulseCircles.push({
                x, y,
                radius: 5,
                growing: true,
                color: currentColor,
                alpha: 1
            });
        }
        
        function createSpiral(x, y) {
            effects.spirals.push({
                x, y,
                angle: 0,
                radius: 0,
                speed: Math.random() * 0.1 + 0.05,
                color: `hsl(${Math.random() * 360}, 100%, 50%)`
            });
        }
        
        function createSpaceDust(x, y) {
            for (let i = 0; i < 10; i++) {
                effects.spaceDust.push({
                    x, y,
                    vx: Math.random() * 4 - 2,
                    vy: Math.random() * 4 - 2,
                    size: Math.random() * 2 + 1,
                    color: `hsl(${Math.random() * 60 + 200}, 100%, ${Math.random() * 30 + 50}%)`,
                    life: Math.random() * 100 + 50
                });
            }
        }
        
        function createFlowerParticle(x, y) {
            effects.flowerParticles.push({
                x, y,
                size: Math.random() * 10 + 5,
                petals: Math.floor(Math.random() * 6) + 4,
                angle: Math.random() * Math.PI * 2,
                color: `hsl(${Math.random() * 60 + 300}, 100%, 70%)`
            });
        }
        
        function createFloatingBall(x, y) {
            effects.floatingBalls.push({
                x, y,
                radius: Math.random() * 20 + 10,
                vx: Math.random() * 2 - 1,
                vy: Math.random() * 2 - 1,
                color: `hsla(${Math.random() * 360}, 100%, 60%, 0.7)`,
                orbitRadius: Math.random() * 50 + 20,
                orbitAngle: Math.random() * Math.PI * 2
            });
        }
        
        function createVanGoghStroke(x, y) {
            effects.vanGoghBrush.push({
                x, y,
                size: Math.random() * 15 + 5,
                angle: Math.random() * Math.PI * 2,
                color: `hsl(${Math.random() * 60 + 40}, 100%, 60%)`
            });
        }
        
        function createSquareTile(x, y) {
            effects.squareTiles.push({
                x, y,
                size: Math.random() * 30 + 10,
                rotation: Math.random() * Math.PI / 4,
                color: `hsl(${Math.random() * 360}, 80%, 60%)`
            });
        }
        
        function createNeuron(x, y) {
            effects.neurons.push({
                x, y,
                connections: [],
                fired: true,
                energy: 1
            });
        }
        
        function createChaosShape(x, y) {
            effects.chaosShapes.push({
                x, y,
                sides: Math.floor(Math.random() * 5) + 3,
                size: Math.random() * 30 + 10,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: Math.random() * 0.02 - 0.01,
                color: `hsl(${Math.random() * 360}, 100%, 60%)`
            });
        }
        
        // Анимация и рендеринг
        function animate() {
            // Полупрозрачный фон для эффектов с накоплением
            if ([1, 3, 5, 7, 11, 14, 19, 20].includes(currentEffect)) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else if ([2, 4, 6, 8, 9, 10, 12, 13, 15, 16, 17, 18].includes(currentEffect)) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Отрисовка текущего эффекта
            switch(currentEffect) {
                case 1: updateFireParticles(); break;
                case 2: updateRipples(); break;
                case 3: updateStarTrails(); break;
                case 4: updateRainbowLines(); break;
                case 5: updateCellularAutomata(); break;
                case 6: updateBranches(); break;
                case 7: updateLightning(); break;
                case 8: updateBubbles(); break;
                case 9: updateSnowflakes(); break;
                case 10: updateMetallicThreads(); break;
                case 11: updateSmoke(); break;
                case 12: updatePulseCircles(); break;
                case 13: updateSpirals(); break;
                case 14: updateSpaceDust(); break;
                case 15: updateFlowerParticles(); break;
                case 16: updateFloatingBalls(); break;
                case 17: updateVanGoghBrush(); break;
                case 18: updateSquareTiles(); break;
                case 19: updateNeurons(); break;
                case 20: updateChaosShapes(); break;
            }
            
            requestAnimationFrame(animate);
        }
        
        // Функции обновления для каждого эффекта
        function updateFireParticles() {
            effects.particles.forEach((p, i) => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                p.size *= 0.98;
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 100;
                ctx.fill();
                ctx.globalAlpha = 1;
                
                if (p.life <= 0) {
                    effects.particles.splice(i, 1);
                }
            });
        }
        
        function updateRipples() {
            effects.ripples.forEach((r, i) => {
                r.radius += 2;
                r.alpha -= 0.01;
                
                ctx.beginPath();
                ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
                ctx.strokeStyle = r.color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = r.alpha;
                ctx.stroke();
                ctx.globalAlpha = 1;
                
                if (r.alpha <= 0) {
                    effects.ripples.splice(i, 1);
                }
            });
        }
        
        function updateStarTrails() {
            effects.stars.forEach((s, i) => {
                s.twinkle = Math.sin(Date.now() * 0.001 * s.speed) * 0.5 + 0.5;
                
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${s.twinkle})`;
                ctx.fill();
                
                // Случайное мерцание
                if (Math.random() < 0.05) {
                    ctx.beginPath();
                    ctx.arc(s.x + (Math.random() * 6 - 3), s.y + (Math.random() * 6 - 3), 
                           s.size * 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fill();
                }
            });
        }
        
        function updateRainbowLines() {
            effects.rainbowLines.forEach(line => {
                if (line.points.length < 2) return;
                
                ctx.beginPath();
                ctx.moveTo(line.points[0].x, line.points[0].y);
                
                for (let i = 1; i < line.points.length; i++) {
                    const p = line.points[i];
                    ctx.lineTo(p.x, p.y);
                }
                
                ctx.lineWidth = 3;
                ctx.strokeStyle = `hsl(${line.points[line.points.length-1].hue}, 100%, 50%)`;
                ctx.stroke();
            });
        }
        
        function updateCellularAutomata() {
            const cols = Math.ceil(canvas.width / effects.cellSize);
            const rows = Math.ceil(canvas.height / effects.cellSize);
            
            // Инициализация, если нужно
            if (effects.cells.length !== cols * rows) {
                effects.cells = new Array(cols * rows).fill(null);
            }
            
            // Отрисовка клеток
            effects.cells.forEach((cell, i) => {
                if (cell && cell.active) {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const x = col * effects.cellSize;
                    const y = row * effects.cellSize;
                    
                    ctx.fillStyle = currentColor;
                    ctx.globalAlpha = cell.energy;
                    ctx.fillRect(x, y, effects.cellSize, effects.cellSize);
                    ctx.globalAlpha = 1;
                    
                    // Распространение энергии
                    cell.energy *= 0.95;
                    if (cell.energy < 0.1) {
                        cell.active = false;
                    }
                    
                    // Активация соседей
                    if (Math.random() < 0.1) {
                        const neighbors = [
                            i - 1, i + 1, 
                            i - cols, i + cols,
                            i - cols - 1, i - cols + 1,
                            i + cols - 1, i + cols + 1
                        ].filter(n => n >= 0 && n < cols * rows);
                        
                        neighbors.forEach(n => {
                            if (!effects.cells[n]) {
                                effects.cells[n] = {
                                    active: true,
                                    energy: cell.energy * 0.8,
                                    neighbors: []
                                };
                            } else if (!effects.cells[n].active) {
                                effects.cells[n].active = true;
                                effects.cells[n].energy = cell.energy * 0.8;
                            }
                        });
                    }
                }
            });
        }
        
        function updateBranches() {
            effects.branches.forEach((b, i) => {
                if (b.depth < b.maxDepth) {
                    const newX = b.x + Math.cos(b.angle) * b.length;
                    const newY = b.y + Math.sin(b.angle) * b.length;
                    
                    ctx.beginPath();
                    ctx.moveTo(b.x, b.y);
                    ctx.lineTo(newX, newY);
                    ctx.strokeStyle = currentColor;
                    ctx.lineWidth = 3 - (b.depth / b.maxDepth * 2);
                    ctx.stroke();
                    
                    // Создаем новые ветви
                    if (Math.random() < 0.3) {
                        effects.branches.push({
                            x: newX, y: newY,
                            angle: b.angle + (Math.random() * 0.6 - 0.3),
                            length: b.length * 0.8,
                            depth: b.depth + 1,
                            maxDepth: b.maxDepth
                        });
                    }
                    
                    effects.branches.splice(i, 1);
                }
            });
        }
        
        function updateLightning() {
            effects.lightning.forEach((l, i) => {
                l.life--;
                
                if (l.segments.length === 0) {
                    // Создаем первый сегмент
                    l.segments.push({
                        x1: l.x,
                        y1: l.y,
                        x2: l.x + (Math.random() * 40 - 20),
                        y2: l.y + (Math.random() * 40 - 20)
                    });
                } else {
                    // Добавляем новые сегменты
                    const lastSegment = l.segments[l.segments.length - 1];
                    if (Math.random() < 0.7 && l.segments.length < 20) {
                        l.segments.push({
                            x1: lastSegment.x2,
                            y1: lastSegment.y2,
                            x2: lastSegment.x2 + (Math.random() * 40 - 20),
                            y2: lastSegment.y2 + (Math.random() * 40 - 20)
                        });
                    }
                }
                
                // Отрисовка
                ctx.lineWidth = 2;
                ctx.strokeStyle = `rgba(100, 150, 255, ${l.life / 30})`;
                ctx.beginPath();
                
                l.segments.forEach((seg, j) => {
                    if (j === 0) {
                        ctx.moveTo(seg.x1, seg.y1);
                    }
                    ctx.lineTo(seg.x2, seg.y2);
                    
                    // Ветвление
                    if (Math.random() < 0.2 && j > 0) {
                        ctx.moveTo(seg.x2, seg.y2);
                        ctx.lineTo(
                            seg.x2 + (Math.random() * 20 - 10),
                            seg.y2 + (Math.random() * 20 - 10)
                        );
                    }
                });
                
                ctx.stroke();
                
                if (l.life <= 0) {
                    effects.lightning.splice(i, 1);
                }
            });
        }
        
        function updateBubbles() {
            effects.bubbles.forEach((b, i) => {
                b.x += b.vx;
                b.y += b.vy;
                b.radius *= 0.99;
                
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                ctx.fillStyle = b.color;
                ctx.fill();
                
                // Отражение света
                ctx.beginPath();
                ctx.arc(
                    b.x - b.radius * 0.3, 
                    b.y - b.radius * 0.3, 
                    b.radius * 0.2, 
                    0, Math.PI * 2
                );
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fill();
                
                if (b.radius < 2) {
                    effects.bubbles.splice(i, 1);
                }
            });
        }
        
        function updateSnowflakes() {
            effects.snowflakes.forEach((s, i) => {
                s.angle += s.rotationSpeed;
                
                ctx.save();
                ctx.translate(s.x, s.y);
                ctx.rotate(s.angle);
                
                for (let j = 0; j < s.branches; j++) {
                    const angle = (Math.PI * 2 / s.branches) * j;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * s.size, Math.sin(angle) * s.size);
                    
                    // Вторичные ветви
                    for (let k = 0.3; k < 0.9; k += 0.3) {
                        const bx = Math.cos(angle) * s.size * k;
                        const by = Math.sin(angle) * s.size * k;
                        
                        ctx.moveTo(bx, by);
                        ctx.lineTo(
                            bx + Math.cos(angle + Math.PI/2) * s.size * 0.2,
                            by + Math.sin(angle + Math.PI/2) * s.size * 0.2
                        );
                        
                        ctx.moveTo(bx, by);
                        ctx.lineTo(
                            bx + Math.cos(angle - Math.PI/2) * s.size * 0.2,
                            by + Math.sin(angle - Math.PI/2) * s.size * 0.2
                        );
                    }
                    
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }
        
        function updateMetallicThreads() {
            effects.metallicThreads.forEach(thread => {
                if (thread.points.length < 2) return;
                
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                for (let i = 1; i < thread.points.length; i++) {
                    const p1 = thread.points[i-1];
                    const p2 = thread.points[i];
                    
                    const grad = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
                    grad.addColorStop(0, currentColor);
                    grad.addColorStop(1, `hsl(${Math.random() * 60 + 30}, 100%, 70%)`);
                    
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.strokeStyle = grad;
                    ctx.stroke();
                }
            });
        }
        
        function updateSmoke() {
            effects.smokeParticles.forEach((p, i) => {
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= 0.005;
                p.size *= 1.01;
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.alpha;
                ctx.fill();
                ctx.globalAlpha = 1;
                
                if (p.alpha <= 0) {
                    effects.smokeParticles.splice(i, 1);
                }
            });
        }
        
        function updatePulseCircles() {
            effects.pulseCircles.forEach((c, i) => {
                if (c.growing) {
                    c.radius += 1;
                    if (c.radius > 50) c.growing = false;
                } else {
                    c.alpha -= 0.02;
                }
                
                ctx.beginPath();
                ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
                ctx.strokeStyle = c.color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = c.alpha;
                ctx.stroke();
                ctx.globalAlpha = 1;
                
                if (c.alpha <= 0) {
                    effects.pulseCircles.splice(i, 1);
                }
            });
        }
        
        function updateSpirals() {
            effects.spirals.forEach((s, i) => {
                s.angle += 0.1;
                s.radius += s.speed;
                
                const x = s.x + Math.cos(s.angle) * s.radius;
                const y = s.y + Math.sin(s.angle) * s.radius;
                
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fillStyle = s.color;
                ctx.fill();
                
                if (s.radius > 200) {
                    effects.spirals.splice(i, 1);
                }
            });
        }
        
        function updateSpaceDust() {
            effects.spaceDust.forEach((d, i) => {
                d.x += d.vx;
                d.y += d.vy;
                d.life--;
                
                ctx.beginPath();
                ctx.arc(d.x, d.y, d.size, 0, Math.PI * 2);
                ctx.fillStyle = d.color;
                ctx.fill();
                
                // Хвост
                ctx.beginPath();
                ctx.moveTo(d.x, d.y);
                ctx.lineTo(d.x - d.vx * 3, d.y - d.vy * 3);
                ctx.strokeStyle = d.color;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                if (d.life <= 0 || 
                    d.x < 0 || d.x > canvas.width || 
                    d.y < 0 || d.y > canvas.height) {
                    effects.spaceDust.splice(i, 1);
                }
            });
        }
        
        function updateFlowerParticles() {
            effects.flowerParticles.forEach((f, i) => {
                ctx.save();
                ctx.translate(f.x, f.y);
                ctx.rotate(f.angle);
                
                // Центр цветка
                ctx.beginPath();
                ctx.arc(0, 0, f.size * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = `hsl(${Math.random() * 60 + 50}, 100%, 60%)`;
                ctx.fill();
                
                // Лепестки
                for (let j = 0; j < f.petals; j++) {
                    const angle = (Math.PI * 2 / f.petals) * j;
                    
                    ctx.beginPath();
                    ctx.ellipse(
                        Math.cos(angle) * f.size * 0.7, 
                        Math.sin(angle) * f.size * 0.7,
                        f.size * 0.5, 
                        f.size * 0.2, 
                        angle, 
                        0, 
                        Math.PI * 2
                    );
                    ctx.fillStyle = f.color;
                    ctx.fill();
                }
                
                ctx.restore();
                
                // Медленное исчезновение
                if (Math.random() < 0.02) {
                    effects.flowerParticles.splice(i, 1);
                }
            });
        }
        
        function updateFloatingBalls() {
            effects.floatingBalls.forEach((b, i) => {
                b.orbitAngle += 0.02;
                
                // Основное движение
                b.x += b.vx;
                b.y += b.vy;
                
                // Орбитальные точки
                const orbitX = Math.cos(b.orbitAngle) * b.orbitRadius;
                const orbitY = Math.sin(b.orbitAngle) * b.orbitRadius;
                
                // Отрисовка шара
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                ctx.fillStyle = b.color;
                ctx.fill();
                
                // Отрисовка орбитальных точек
                ctx.beginPath();
                ctx.arc(b.x + orbitX, b.y + orbitY, 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fill();
                
                // Отражения
                const grad = ctx.createRadialGradient(
                    b.x - b.radius * 0.3, 
                    b.y - b.radius * 0.3, 
                    1,
                    b.x - b.radius * 0.3, 
                    b.y - b.radius * 0.3, 
                    b.radius * 0.5
                );
                grad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.beginPath();
                ctx.arc(
                    b.x - b.radius * 0.3, 
                    b.y - b.radius * 0.3, 
                    b.radius * 0.5, 
                    0, 
                    Math.PI * 2
                );
                ctx.fillStyle = grad;
                ctx.fill();
                
                // Отскок от границ
                if (b.x < b.radius || b.x > canvas.width - b.radius) b.vx *= -1;
                if (b.y < b.radius || b.y > canvas.height - b.radius) b.vy *= -1;
            });
        }
        
        function updateVanGoghBrush() {
            effects.vanGoghBrush.forEach((s, i) => {
                ctx.save();
                ctx.translate(s.x, s.y);
                ctx.rotate(s.angle);
                
                // Мазок кисти в стиле Ван Гога
                for (let j = 0; j < 5; j++) {
                    const offset = (Math.random() - 0.5) * s.size * 0.5;
                    const length = s.size * (0.5 + Math.random() * 0.5);
                    
                    ctx.beginPath();
                    ctx.moveTo(offset, -length/2);
                    ctx.lineTo(offset, length/2);
                    ctx.strokeStyle = s.color;
                    ctx.lineWidth = 1 + Math.random() * 2;
                    ctx.stroke();
                }
                
                ctx.restore();
                
                // Удаляем старые мазки
                if (Math.random() < 0.05) {
                    effects.vanGoghBrush.splice(i, 1);
                }
            });
        }
        
        function updateSquareTiles() {
            effects.squareTiles.forEach((t, i) => {
                ctx.save();
                ctx.translate(t.x, t.y);
                ctx.rotate(t.rotation);
                
                ctx.fillStyle = t.color;
                ctx.fillRect(-t.size/2, -t.size/2, t.size, t.size);
                
                // Внутренний узор
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                for (let j = 0.1; j < 0.9; j += 0.2) {
                    ctx.strokeRect(
                        -t.size/2 * j, 
                        -t.size/2 * j, 
                        t.size * j, 
                        t.size * j
                    );
                }
                
                ctx.restore();
                
                // Медленное вращение
                t.rotation += 0.005;
                
                // Удаляем старые плитки
                if (Math.random() < 0.01) {
                    effects.squareTiles.splice(i, 1);
                }
            });
        }
        
        function updateNeurons() {
            // Обновляем состояние нейронов
            effects.neurons.forEach((n, i) => {
                if (n.fired) {
                    n.energy -= 0.05;
                    if (n.energy <= 0) {
                        n.fired = false;
                        n.energy = 0;
                    }
                }
                
                // Создаем случайные связи
                if (Math.random() < 0.1 && effects.neurons.length > 1) {
                    const other = effects.neurons[Math.floor(Math.random() * effects.neurons.length)];
                    if (other !== n) {
                        n.connections.push({
                            target: other,
                            strength: Math.random()
                        });
                        
                        // Ограничиваем количество связей
                        if (n.connections.length > 5) {
                            n.connections.shift();
                        }
                    }
                }
            });
            
            // Отрисовка
            effects.neurons.forEach((n, i) => {
                // Тело нейрона
                ctx.beginPath();
                ctx.arc(n.x, n.y, 5 + n.energy * 10, 0, Math.PI * 2);
                ctx.fillStyle = n.fired ? 
                    `rgba(100, 200, 255, ${n.energy})` : 
                    'rgba(100, 100, 100, 0.5)';
                ctx.fill();
                
                // Аксоны (связи)
                n.connections.forEach(conn => {
                    if (conn.target.fired) {
                        ctx.beginPath();
                        ctx.moveTo(n.x, n.y);
                        ctx.lineTo(conn.target.x, conn.target.y);
                        ctx.strokeStyle = `rgba(100, 200, 255, ${conn.strength * 0.5})`;
                        ctx.lineWidth = 1 + conn.strength * 2;
                        ctx.stroke();
                        
                        // Передача импульса
                        if (Math.random() < 0.1 && !n.fired) {
                            n.fired = true;
                            n.energy = 1;
                        }
                    }
                });
                
                // Удаляем старые нейроны
                if (Math.random() < 0.01 && !n.fired && n.connections.length === 0) {
                    effects.neurons.splice(i, 1);
                }
            });
        }
        
        function updateChaosShapes() {
            effects.chaosShapes.forEach((s, i) => {
                s.rotation += s.rotationSpeed;
                
                ctx.save();
                ctx.translate(s.x, s.y);
                ctx.rotate(s.rotation);
                
                // Рисуем многоугольник
                ctx.beginPath();
                for (let j = 0; j < s.sides; j++) {
                    const angle = (Math.PI * 2 / s.sides) * j;
                    const x = Math.cos(angle) * s.size;
                    const y = Math.sin(angle) * s.size;
                    
                    if (j === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                
                // Градиентная заливка
                const grad = ctx.createRadialGradient(0, 0, 1, 0, 0, s.size);
                grad.addColorStop(0, s.color);
                grad.addColorStop(1, `hsl(${Math.random() * 360}, 100%, 50%)`);
                
                ctx.fillStyle = grad;
                ctx.fill();
                
                // Хаотичные линии внутри
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                for (let j = 0; j < 5; j++) {
                    ctx.beginPath();
                    const a1 = Math.random() * Math.PI * 2;
                    const a2 = a1 + Math.random() * Math.PI;
                    ctx.arc(0, 0, s.size * (0.2 + Math.random() * 0.8), a1, a2);
                    ctx.stroke();
                }
                
                ctx.restore();
                
                // Движение
                s.x += Math.cos(s.rotation) * 2;
                s.y += Math.sin(s.rotation) * 2;
                
                // Удаляем формы, выходящие за границы
                if (s.x < -s.size * 2 || s.x > canvas.width + s.size * 2 ||
                    s.y < -s.size * 2 || s.y > canvas.height + s.size * 2) {
                    effects.chaosShapes.splice(i, 1);
                }
            });
        }
        
        // Запуск анимации
        animate();
    </script>
</body>
</html>